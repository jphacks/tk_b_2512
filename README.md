# ozendate

[![IMAGE ALT TEXT HERE](https://jphacks.com/wp-content/uploads/2025/05/JPHACKS2025_ogp.jpg)](https://www.youtube.com/watch?v=lA9EluZugD8)


## 製品概要
### 背景
オンラインで器を探しても種類が多く、自分のテーブルに似合うものがどれなのか選びきれない。
また、商品写真だけだと実際に置いた時のイメージがわきにくく、購入に踏み切れない。

### 製品説明
ozendateは、AIでテーブルコーディネートを試しながら、楽しくオンラインで器を選べるサービスだ。

#### 使い方
1. 現状のテーブルコーディネートをアップロード
2. 新しい器を配置したい領域を選択
3. AIが商品リストの中からいくつか器をレコメンド
    - 現状のテーブルコーディネートの雰囲気や、他の器の色・形を考慮してくれる
4. ユーザが候補の中から選択
5. テーブルに新たな器を置いた画像を、AIが生成
    - まず、複数の画像を重ねた一枚の画像を用意する。その後、自然な画像になるようAIに処理させる。

### 特長
#### 1. 購入プロセス自体を、ワクワクする楽しい時間に変えることができる。
- 頭の中にしかなかったコーディネートのイメージを実際に手元で動かしながら、新しい組み合わせを発見していく体験ができる。
- オンラインだからこそできる、新しい体験だと言える。

#### 2. ecサイトの新たなレコメンド方法を提供。
- 今までのecサイトは**購入履歴**を元にレコメンドしていた。
- 今回はユーザの**現状の願望、意思**を元にレコメンドする。

#### 3. AIによる直感的で分かりやすい画像を得られる。
- Human in the Loop のAPI利用により、ユーザの要求と生成AIの画像編集機能を統合。
- 直感的なUI操作でユーザの求める内容を把握し、写真とアイテムに基づきオーナーシップの高い画像編集を実現。
- 最新の Gemini API と伝統的な Computer Vision 技術の統合で理想のテーブルコーディネートを提供。

### 解決出来ること
- AIが大量の商品の中から自分の意向に沿った商品を絞って提示することによって、本当に欲しい商品を選択するのが楽になる。
- イメージが視覚化されて、購入前の不安を取り除くことができる。

### 今後の展望
- データ取得
    - 商品リストを実在するecサイトから取得するよう変更する。
    - プロトタイプでは、事前に入力済みのデータを用いて表示
- 既存のテーブルコーディネート調整機能の追加。
    - プロトタイプでは、既存の器配置は固定している。
    - 既存のテーブルコーディネート含め、最適な配置を提示する。
- 購入意思が明確なユーザー向けのシミュレーションサービスを拡充させる。
    - サービス概要  
        1. 現状のテーブルコーディネートをアップロード
        2. ユーザが追加したい器を追加したい領域にドラッグ
        3. AIがコラージュし、画像生成
        4. サイズも考慮した自然な画像を表示する

### 注力したこと、こだわり
- アイデア出し
    - それぞれが持ち寄った6つのアイデアに対して、各々のプロトタイプを作成した。その上で、独自性や新規性、課題の明確さが優れているアイデアを選定した。
    - アイデア選定後、一番解決したい課題を明確にし、やりたいことの優先順位を決定した。
* フロントエンドフレームワークとして React を導入
    + 画面遷移を用いないユーザ体験に寄り添ったウェブアプリケーションとして構築
    + 画面更新時のパフォーマンス上の負荷を抑える
    + 責務に応じたコンポーネントの分割でAIにとってもエンジニアにとっても可読性が高く修正しやすいコーディングスタイルを採用
    + 状態管理に React Hooks を用い小規模のプロジェクトサイズに対し適切な規模の状態管理を実現
* CSSフレームワークとして Tailwind CSS を導入
    + 素早いコーディングで洗練されたUIコンポーネントを実現
    + 独自のCSSとも組み合わせ可能な柔軟な構成
    + Javascript フレームワークである React ともシームレスに統合
*  複数人開発の工程管理
    + GitHub Flow : 開発内容であるissueと直接対応するbranchを通じて変更の早さにも対応できるようなバージョン管理に基づく開発を実行
    + prefix
        - commit および issue を prefix で区切ることにより各 commit を意味的に単一なものに統制し適切な粒度となるようにコントロール
        - prefixにより過去の commit の内容をより直感的に把握

## 開発技術
### 活用した技術
#### API・データ
- Gemini API (`gemini-2.5-flash`)

#### フレームワーク・ライブラリ・モジュール
- React
- Tailwind CSS

#### 動作環境
- スマートフォン、タブレット、PC に対応
  - レスポンシブ対応

#### スクラム開発
* GitHub Flow
* prefix

### 今後導入する技術
#### フレームワーク・ライブラリ・モジュール
- `Node.js`
    * 24.10.0
    * nodenv
    * enyenv


### 独自技術
#### ハッカソンで開発した独自機能・技術
* 独自機能
    * 複数の画像を重ね合わせた一枚の画像を用意した後に、AIが自然な画像にするよう処理する。

   
# [prefix（プレフィックス）](https://qiita.com/numanomanu/items/45dd285b286a1f7280ed)
- chore
    * プロジェクト作成やライブラリの追加
- feat
    * 機能・処理の新規追加 / 未完成機能の進捗
- update
    * 完成した機能・処理の修正
- fix
    * バグ修正
- style
    * ソースコードのスタイル修正（改行など）
- refactor
    * ソースコードのリファクタリング
- doc
    * ドキュメント追加・編集


# 開発フロー
## issue駆動開発 ＋ GitHubフロー
1. issueで仕事を割り当て
2. 命名規則に従ったブランチを作って開発
3. prefixをつけて適宜commit
4. 完成したらテストとLinterが通るかを確認
    1. `rails test`
    2. `rubocop`
5. 問題がなければプルリクエストを作成

## ブランチ命名規則
```
[prefix]/[issue番号]/[issue内容]
```

またはissueが無い場合は
```
[prefix]/date-[yyyymmdd]/[branch内容]
```

### 例
```
chore/1/setup-rails
```

```
feat/2/user-model
```

```
doc/date-20200119/separate-readme-to-some-docs
```

