# ozendate

[![IMAGE ALT TEXT HERE](https://jphacks.com/wp-content/uploads/2025/05/JPHACKS2025_ogp.jpg)](https://www.youtube.com/watch?v=lA9EluZugD8)
README

## 製品概要
### 背景(製品開発のきっかけ、課題等）
オンラインで器を探しても種類が多く、自分のテーブルに似合うものがどれなのか選びきれない。
また、商品写真だけだと実際に置いた時のイメージがわかない。

### 製品説明（具体的な製品の説明）
自分の現状のテーブルコーディネートに合う器をAIがレコメンドしてくれる。

#### 使い方
1. 現状のテーブルコーディネートをアップロード
2. 新しい器を配置したい領域を選択
3. AIが商品リストの中からいくつか器をレコメンド
    - 現状のテーブルコーディネートの雰囲気や、他の器の色・形を考慮してくれる
4. ユーザが候補の中から選択
5. AIがコラージュ、画像生成



### 特長
#### 1. 特長1(独自性アピ)
購入プロセス自体を、ワクワクする楽しい時間に変えることができる。
- 頭の中にしかなかったコーディネートのイメージを実際に手元で動かしながら、新しい組み合わせを発見していく体験ができる。
- オンラインだからこそできる、新しい体験だと言える。

#### 2. 特長2(独自性)
ecサイトの新たなレコメンド方法を提供。
- 今までのecサイトは**購入履歴**を元にレコメンドしていた。
- 今回はユーザの**現状の願望、意思**を元にレコメンドする。

#### 3. 特長3(技術)
- Human in the Loop のAPI利用により、ユーザの要求と生成AIの画像編集機能を統合。
- 直感的なUI操作でユーザの求める内容を把握し、写真とアイテムに基づきオーナーシップの高い画像編集を実現。
- 最新の Gemini API と伝統的な Computer Vision 技術の統合で理想のテーブルコーディネートを提供。


### 解決出来ること
- AIがおすすめの器を厳選してくれることで、大量の商品リストから欲しい商品を選択するのが楽になる。
- イメージが視覚化されて、購入前の不安を取り除くことができる。

### 今後の展望
- データ取得
    - 商品リストを実在するecサイトから取得するよう変更する。
    - プロトタイプでは、事前に入力済みのデータを用いて表示
- 既存のテーブルコーディネートも適切に調整する機能を追加する。
    - プロトタイプでは、既存のテーブルコーディネートは固定している。
- [追加機能] 買いたい商品が決まっている人むけのシミュレーションサービス
    - 現状のテーブルコーディネートをアップロード
    - ユーザが追加したい器を追加したい領域にドラッグ
    - コラージュ、画像生成
    - サイズも考慮して自然な画像にしたい(今はやらない)

### 注力したこと（こだわり等）
- アイデア出し
    - 課題を明確にした。

## 開発技術
### 活用した技術
#### API・データ
- Gemini API (`gemini-2.5-flash`)

#### フレームワーク・ライブラリ・モジュール
- React
- Tailwind CSS

#### 動作環境
- スマートフォン、タブレット、PC に対応
  - レスポンシブ対応

#### スクラム開発
* GitHub Flow
* prefix

### 今後導入する技術
#### フレームワーク・ライブラリ・モジュール
- `Node.js`
    * 24.10.0
    * nodenv
    * enyenv


### 独自技術
#### ハッカソンで開発した独自機能・技術
* 独自で開発したものの内容をこちらに記載してください
* 特に力を入れた部分をファイルリンク、またはcommit_idを記載してください。


   
# [prefix（プレフィックス）](https://qiita.com/numanomanu/items/45dd285b286a1f7280ed)
- chore
    * プロジェクト作成やライブラリの追加
- feat
    * 機能・処理の新規追加 / 未完成機能の進捗
- update
    * 完成した機能・処理の修正
- fix
    * バグ修正
- style
    * ソースコードのスタイル修正（改行など）
- refactor
    * ソースコードのリファクタリング
- doc
    * ドキュメント追加・編集


# 開発フロー
## issue駆動開発 ＋ GitHubフロー
1. issueで仕事を割り当て
2. 命名規則に従ったブランチを作って開発
3. prefixをつけて適宜commit
4. 完成したらテストとLinterが通るかを確認
    1. `rails test`
    2. `rubocop`
5. 問題がなければプルリクエストを作成

## ブランチ命名規則
```
[prefix]/[issue番号]/[issue内容]
```

またはissueが無い場合は
```
[prefix]/date-[yyyymmdd]/[branch内容]
```

### 例
```
chore/1/setup-rails
```

```
feat/2/user-model
```

```
doc/date-20200119/separate-readme-to-some-docs
```

